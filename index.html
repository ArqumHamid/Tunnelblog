<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Music Tunnel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; background: black; color: white; text-align: center; }
        #controls { position: absolute; top: 10px; width: 100%; z-index: 10; }
        input, button { margin: 5px; padding: 10px; }
    </style>
</head>
<body>
    <div id="controls">
        <input type="file" id="fileInput" multiple accept="audio/*">
        <button onclick="playMusic()">Play</button>
    </div>
    <script>
        let audioContext, analyser, source, audioBuffer;
        let fileQueue = [];
        let isPlaying = false;
        
        // Prevent screen from sleeping
        let wakeLock = null;
        async function keepScreenAwake() {
            if ('wakeLock' in navigator) {
                try {
                    wakeLock = await navigator.wakeLock.request('screen');
                } catch (err) {
                    console.log("Wake lock error:", err);
                }
            }
        }

        // Handle file selection
        document.getElementById("fileInput").addEventListener("change", function(event) {
            fileQueue = Array.from(event.target.files);
        });

        function playMusic() {
            if (fileQueue.length === 0) return alert("Please select at least one song!");

            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
            }

            if (isPlaying) {
                stopMusic();
            }

            playNextSong();
            keepScreenAwake();
        }

        function playNextSong() {
            if (fileQueue.length === 0) return;

            let file = fileQueue.shift();
            let reader = new FileReader();
            reader.onload = function(event) {
                audioContext.decodeAudioData(event.target.result, function(buffer) {
                    if (source) source.stop();
                    audioBuffer = buffer;
                    source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(analyser);
                    analyser.connect(audioContext.destination);
                    source.start(0);
                    isPlaying = true;
                    startVisualization();
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function stopMusic() {
            if (source) source.stop();
            isPlaying = false;
            fileQueue = [];
            if (wakeLock) wakeLock.release();
        }

        // 3D Tunnel Visualization
        let scene = new THREE.Scene();
        let camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        let renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        let geometry = new THREE.CylinderGeometry(5, 5, 50, 32, 1, true);
        let material = new THREE.MeshBasicMaterial({ color: 0xffffff, wireframe: true });
        let tunnel = new THREE.Mesh(geometry, material);
        scene.add(tunnel);

        camera.position.z = 5;

        function startVisualization() {
            function animate() {
                if (!isPlaying) return;

                requestAnimationFrame(animate);
                tunnel.rotation.z += 0.005;

                // Dynamic illusions (Random effects based on frequency)
                let dataArray = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(dataArray);
                let averageFreq = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;

                tunnel.rotation.y += averageFreq * 0.0001;
                tunnel.scale.x = tunnel.scale.y = 1 + (averageFreq * 0.002);
                material.color.setHSL(Math.random(), 1, 0.5);

                renderer.render(scene, camera);
            }
            animate();
        }

        window.addEventListener("resize", function() {
            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        });
    </script>
</body>
</html>
